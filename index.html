<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEMORY CRYSTAL INTERFACE</title>
    <link rel="stylesheet" href="/src/style.css">
    <style>
        /* Base theme */
        :root {
            --primary-green: #00ff00;
            --button-yellow: #ffda0f;
            --dark-bg: #000000;
            --panel-bg: rgba(0, 0, 0, 0.95);
            --border-color: rgba(255, 255, 255, 1);
            --metallic-border: linear-gradient(45deg, #ffffff, #e0e0e0, #ffffff);
            --border-width: 2px;
            --screen-glow: 0 0 15px rgba(255, 255, 255, 0.3);
            --border-radius: 20px;
            --screen-bg: rgba(0, 0, 0, 0.98);
            --grid-overlay: repeating-linear-gradient(
                0deg,
                rgba(0, 255, 0, 0.03) 0px,
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 50px
            ),
            repeating-linear-gradient(
                90deg,
                rgba(0, 255, 0, 0.03) 0px,
                rgba(0, 255, 0, 0.03) 1px,
                transparent 1px,
                transparent 50px
            );
            --tv-static: url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.99' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        body {
            background: var(--dark-bg);
            color: var(--primary-green);
            font-family: "VT323", monospace;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            background-image: 
                radial-gradient(circle at 50% 50%, rgba(0, 255, 0, 0.03) 0%, transparent 50%),
                linear-gradient(45deg, rgba(0, 0, 0, 0.97) 0%, rgba(0, 20, 0, 0.97) 100%);
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Main dashboard layout */
        #dashboard {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            grid-template-rows: auto auto auto;
            gap: 30px;
            position: relative;
        }

        /* Center Panel: Command Interface */
        .command-interface {
            grid-column: 2 / span 10;
            grid-row: 1;
            height: 400px;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 25px;
            background: var(--screen-bg);
            box-shadow: var(--screen-glow);
            border: var(--border-width) solid var(--border-color);
            width: 100%;
        }

        /* Function Circles Panel */
        .dashboard-panel {
            grid-column: 2 / span 10;
            grid-row: 2;
            background: var(--panel-bg);
            padding: 30px;
            height: fit-content;
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            gap: 30px;
            border: var(--border-width) solid var(--border-color);
        }

        /* 3D Model Space */
        .model-space {
            grid-column: 11 / span 2;
            grid-row: 1;
            min-height: 250px;
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            margin: 0;
            position: relative;
        }

        /* Crystal Vault */
        .crystal-vault {
            grid-column: 2 / span 10;
            grid-row: 3;
            margin: 0;
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            padding: 25px;
            border-radius: var(--border-radius);
            position: relative;
            max-height: 600px;
            overflow-y: auto;
            width: 100%;
        }

        /* Token section adjustments */
        .token-section {
            width: 70%;
            max-width: 400px;
            margin: 0 auto 15px;
            padding: 12px;
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            border-radius: var(--border-radius);
        }

        /* Function circle adjustments */
        .function-circle {
            width: 280px;
            aspect-ratio: 1;
            border-radius: 50%;
            background: var(--screen-bg);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            justify-content: center;
            align-items: center;
            position: relative;
            border: var(--border-width) solid var(--border-color);
        }

        .function-circle input,
        .function-circle select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 8px;
            width: 90%;
            margin: 5px auto;
            text-align: center;
            color: #FFFFFF;
            font-weight: bold;
            font-size: 14px;
        }

        .function-circle input::placeholder {
            color: rgba(255, 255, 255, 0.6);
            font-weight: normal;
        }

        .function-circle select {
            color: #FFFFFF;
            font-weight: bold;
        }

        .function-circle select option {
            background: var(--dark-bg);
            color: #FFFFFF;
            font-weight: bold;
        }

        .function-circle h2 {
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        /* Screen styling */
        .screen {
            background: var(--screen-bg);
            padding: 15px;
            position: relative;
            overflow: hidden;
        }

        .screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--grid-overlay);
            pointer-events: none;
            opacity: 1;
        }

        /* Header styling */
        header {
            grid-column: span 12;
            text-align: center;
            padding: 1rem 0;
        }

        .title {
            font-size: 1.8rem;
            color: var(--primary-green);
            text-shadow: 0 0 8px var(--primary-green);
            margin-bottom: 1.5rem;
            letter-spacing: 2px;
        }

        /* Main layout updates */
        .main-circle {
            display: none;
        }

        /* Update function circles */
        .function-circle {
            width: 280px;
            height: 280px;
            border-radius: 50%;
            background: var(--screen-bg);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin: 10px auto;
            position: relative;
            border: var(--border-width) solid var(--border-color);
        }

        .function-circle h2 {
            font-size: 1.2rem;
            text-align: center;
            white-space: normal;
            line-height: 1.2;
            margin-bottom: 5px;
        }

        .function-circle input,
        .function-circle select {
            width: 180px;
            margin: 5px 0;
        }

        .crystal-type-price {
            font-size: 0.8rem;
            color: var(--primary-green);
            margin-top: -5px;
            text-align: center;
        }

        /* Update crystal type select styling */
        #crystalType {
            width: 220px;
            margin-bottom: 10px;
            text-align: center;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        #crystalType option {
            padding: 8px;
            background: var(--dark-bg);
            color: var(--primary-green);
        }

        .crystal-price-info {
            display: none;
        }

        /* Remove absolute positioning styles */
        .swap-circle, .share-circle, .forge-circle {
            position: relative;
            top: auto;
            right: auto;
            transform: none;
        }

        /* Update command interface */
        .command-interface::before {
            content: '';
            position: absolute;
            top: calc(-1 * var(--border-width));
            right: calc(-1 * var(--border-width));
            bottom: calc(-1 * var(--border-width));
            left: calc(-1 * var(--border-width));
            background: var(--metallic-border);
            border-radius: var(--border-radius);
            z-index: -1;
        }

        .command-history {
            flex: 1;
            overflow-y: auto;
            font-family: "Courier New", monospace;
            font-size: 16px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            text-transform: uppercase;
            line-height: 1.6;
        }

        .command-input-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: var(--border-width) solid var(--border-color);
        }

        .command-directory-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            font-size: 0.8rem;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            cursor: pointer;
            z-index: 10;
        }

        .command-directory {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            padding: 20px;
            width: 80%;
            max-height: 80%;
            overflow-y: auto;
            z-index: 100;
        }

        .command-directory.active {
            display: block;
        }

        .command-directory h3 {
            color: var(--primary-green);
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .command-list {
            display: grid;
            gap: 10px;
        }

        .command-item {
            display: grid;
            grid-template-columns: 150px 1fr;
            gap: 10px;
            padding: 5px 0;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }

        .command-name {
            color: var(--button-yellow);
            font-family: "Courier New", monospace;
        }

        .command-desc {
            color: var(--primary-green);
            font-size: 0.9rem;
        }

        .command-prompt {
            color: var(--primary-green);
            font-family: "Courier New", monospace;
        }

        #commandInput {
            flex: 1;
            background: transparent;
            border: none;
            font-size: 16px;
            text-transform: uppercase;
        }

        .command-message {
            margin: 4px 0;
            line-height: 1.4;
        }

        .command-message.system {
            color: var(--primary-green);
        }

        .command-message.user {
            color: var(--button-yellow);
        }

        /* Input styling */
        input, select {
            font-family: "Courier New", monospace;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            padding: 8px 12px;
        }

        input:focus, select:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* Button updates */
        button {
            background: rgba(255, 218, 15, 0.1);
            color: var(--button-yellow);
            border: 1px solid var(--button-yellow);
            font-family: "VT323", monospace;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.9rem;
            letter-spacing: 1px;
        }

        button:hover {
            background: rgba(255, 218, 15, 0.2);
            box-shadow: 0 0 15px rgba(255, 218, 15, 0.4);
        }

        /* Command interface styling */
        .command-response {
            background: rgba(0, 15, 30, 0.8);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
        }

        /* Preserve existing functionality styles but update colors */
        button:disabled {
            background: rgba(128, 128, 128, 0.1);
            border-color: #666;
            color: #666;
            cursor: not-allowed;
        }

        /* Update status indicators */
        #status {
            margin-top: 20px;
            padding: 10px;
            border-radius: 2px;
        }

        .success {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
        }

        .error {
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff0000;
            color: #ff4444;
        }

        /* Update section styling */
        .wallet-section {
            background: var(--panel-bg);
            border: 1px solid var(--primary-green);
            padding: 10px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
        }

        .address-container {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            position: relative;
        }

        #walletAddress {
            color: rgba(255, 255, 255, 0.7);
            font-family: monospace;
        }

        .copy-button {
            background: none;
            border: none;
            color: var(--primary-green);
            cursor: pointer;
            padding: 2px;
            margin: 0 5px;
            font-size: 1rem;
            transition: transform 0.2s ease;
        }

        .copy-button:hover {
            transform: scale(1.1);
        }

        .balance {
            font-size: 0.9rem;
            margin-bottom: 2px;
        }

        /* Add holographic animations */
        @keyframes scanline {
            0% {
                transform: translateY(-100%);
            }
            100% {
                transform: translateY(100%);
            }
        }

        @keyframes glitch {
            0% {
                clip-path: inset(40% 0 61% 0);
                transform: translate(-2px, 2px);
            }
            20% {
                clip-path: inset(92% 0 1% 0);
                transform: translate(1px, -3px);
            }
            40% {
                clip-path: inset(43% 0 1% 0);
                transform: translate(-1px, 3px);
            }
            60% {
                clip-path: inset(25% 0 58% 0);
                transform: translate(3px, 1px);
            }
            80% {
                clip-path: inset(54% 0 7% 0);
                transform: translate(-3px, -2px);
            }
            100% {
                clip-path: inset(58% 0 43% 0);
                transform: translate(2px, 2px);
            }
        }

        .hologram::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: rgba(0, 243, 255, 0.2);
            animation: scanline 6s linear infinite;
            pointer-events: none;
        }

        .glitch-container {
            position: relative;
        }

        .glitch-container h1 {
            position: relative;
        }

        .glitch-container h1::before,
        .glitch-container h1::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--dark-bg);
        }

        .glitch-container h1::before {
            animation: glitch 3s infinite linear alternate-reverse;
            color: var(--primary-green);
            z-index: -2;
        }

        .glitch-container h1::after {
            animation: glitch 2s infinite linear alternate-reverse;
            color: var(--primary-green);
            z-index: -1;
        }

        /* Update input styling */
        input[type="text"],
        input[type="number"] {
            background: rgba(0, 15, 30, 0.6);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            padding: 8px 12px;
            border-radius: 2px;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus,
        input[type="number"]:focus {
            outline: none;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        /* Metallic border effect */
        .metallic-border {
            position: relative;
            border: var(--border-width) solid transparent;
            border-radius: var(--border-radius);
            background-clip: padding-box;
        }

        .metallic-border::before {
            content: '';
            position: absolute;
            top: calc(-1 * var(--border-width));
            right: calc(-1 * var(--border-width));
            bottom: calc(-1 * var(--border-width));
            left: calc(-1 * var(--border-width));
            background: var(--metallic-border);
            border-radius: var(--border-radius);
            z-index: -1;
        }

        /* TV static effect */
        .screen-static {
            position: relative;
            overflow: hidden;
        }

        .screen-static::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: var(--tv-static);
            opacity: 0.08;
            pointer-events: none;
            animation: staticNoise 0.2s steps(2) infinite;
        }

        @keyframes staticNoise {
            0% { transform: translate(-1px, -1px); }
            25% { transform: translate(1px, 1px); }
            50% { transform: translate(-1px, 1px); }
            75% { transform: translate(1px, -1px); }
            100% { transform: translate(-1px, -1px); }
        }

        /* Update select options */
        select option {
            background: var(--dark-bg);
            color: var(--primary-green);
            padding: 8px;
        }

        /* Add swap direction styling */
        .swap-inputs {
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .swap-arrow {
            color: var(--primary-green);
            font-size: 1.2rem;
        }

        .swap-output {
            color: var(--primary-green);
            font-size: 0.9rem;
            text-align: center;
        }

        /* Media player styles */
        .media-player {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            padding: 25px;
            width: 80%;
            max-width: 800px;
            max-height: 80vh;
            z-index: 1000;
            overflow-y: auto;
        }
        
        .media-player.active {
            display: block;
        }
        
        .media-content {
            margin: 20px 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .media-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .media-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: var(--primary-green);
            cursor: pointer;
            font-size: 1.2rem;
        }

        .media-title {
            color: var(--button-yellow);
            font-size: 1.2rem;
            text-align: center;
            margin-bottom: 10px;
        }

        .media-type {
            color: var(--primary-green);
            font-size: 0.9rem;
            text-align: center;
            margin-bottom: 15px;
        }

        /* Media player styles */
        .holder-device {
            width: 300px;
            height: 500px;
            background: linear-gradient(145deg, #1a1a1a, #222);
            border-radius: 30px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 auto;
            border: var(--border-width) solid var(--border-color);
            position: relative;
        }

        .holder-screen {
            width: 260px;
            height: 200px;
            background: var(--screen-bg);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
            position: relative;
            border: var(--border-width) solid var(--border-color);
        }

        .media-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--screen-bg);
            color: var(--primary-green);
        }

        .media-content img,
        .media-content video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .control-wheel {
            width: 200px;
            height: 200px;
            background: #1a1a1a;
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border: var(--border-width) solid var(--border-color);
        }

        .center-button {
            width: 60px;
            height: 60px;
            background: var(--screen-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            color: var(--primary-green);
        }

        .prev-button,
        .next-button,
        .shuffle-button {
            width: 40px;
            height: 40px;
            background: var(--screen-bg);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            cursor: pointer;
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: var(--primary-green);
        }

        .prev-button {
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .next-button {
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .shuffle-button {
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        .shuffle-button.active {
            background: var(--primary-green);
            color: var(--dark-bg);
        }

        .progress-bar {
            width: 90%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            position: absolute;
            bottom: 30px;
            left: 5%;
        }

        .progress {
            width: 0%;
            height: 100%;
            background: var(--primary-green);
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .media-title {
            color: var(--primary-green);
            font-size: 14px;
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .crystal-counter {
            color: var(--primary-green);
            font-size: 12px;
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            text-align: center;
        }

        /* Update crystal card styles */
        .crystal-card {
            background: var(--screen-bg);
            border: var(--border-width) solid var(--border-color);
            padding: 20px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .crystal-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--screen-glow);
        }

        .crystal-title {
            color: var(--button-yellow);
            font-size: 1.1rem;
            font-weight: bold;
        }

        .crystal-type {
            color: var(--primary-green);
            font-size: 0.9rem;
        }

        .crystal-desc {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
        }

        .verify-button {
            margin-left: 10px;
            padding: 2px 8px;
            font-size: 0.8rem;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            cursor: pointer;
        }

        .verify-button:hover {
            background: rgba(0, 255, 0, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
        }

        .copy-tooltip {
            display: none;
            position: absolute;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.8rem;
            margin-left: 5px;
            animation: fadeOut 2s forwards;
        }

        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }

        /* Additional layout adjustments */
        .function-circle input,
        .function-circle select {
            width: 90%;
            margin: 5px auto;
            text-align: center;
        }

        .function-circle button {
            width: 90%;
            margin: 5px auto;
        }

        .command-directory {
            width: 90%;
            max-width: 800px;
            left: 50%;
            transform: translateX(-50%);
        }

        .crystal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 20px;
        }

        /* Responsive adjustments */
        @media (max-width: 1400px) {
            .dashboard-panel {
                padding: 20px;
                gap: 25px;
            }

            .function-circle {
                width: 260px;
            }

            .token-section {
                width: 75%;
            }
        }

        @media (max-width: 1200px) {
            .dashboard-panel {
                flex-direction: column;
            align-items: center;
            }

            .function-circle {
                width: 280px;
            }

            .token-section {
                width: 80%;
            }
        }

        /* Command Interface */
        .command-output {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            line-height: 1.4;
            white-space: pre-wrap;
            color: var(--primary-green);
        }

        .command-input-container {
            display: flex;
            gap: 10px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid var(--border-color);
        }

        .command-input {
            flex: 1;
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid var(--primary-green);
            color: var(--primary-green);
            padding: 8px 12px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        .command-input::placeholder {
            color: rgba(0, 255, 0, 0.5);
        }

        .turn-button {
            background: var(--button-yellow);
            color: var(--dark-bg);
            border: none;
            padding: 8px 20px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .turn-button:hover {
            background: #ffe44d;
            transform: scale(1.05);
        }

        .turn-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans">
    <div class="container">
        <!-- Header Section -->
        <header class="text-center py-8 mb-8 hologram">
            <div class="glitch-container">
                <h1 class="text-4xl font-bold neon-text mb-6" data-text="MEMORY CRYSTAL INTERFACE">MEMORY CRYSTAL INTERFACE</h1>
            </div>
            <div class="mt-6 flex flex-col items-center space-y-4">
                <button id="establishPresence" class="w-64 px-6 py-3 text-lg font-bold hologram">
                    ESTABLISH DIGITAL PRESENCE
                </button>
                <label class="flex items-center space-x-3 text-neon-blue">
                    <input type="checkbox" id="autoConnectToggle" class="w-5 h-5">
                    <span class="text-sm">AUTO-CONNECT TO RESISTANCE NETWORK</span>
            </label>
        </div>
            <div id="networkStatus" class="network-status mt-4"></div>
            <div id="walletError" class="error-message" style="display: none;"></div>
        </header>

        <!-- Main Layout -->
        <main id="dashboard" style="display: none;">
            <!-- Center Panel: Command Interface -->
            <section class="command-interface metallic-border screen-static">
                <button class="command-directory-btn">COMMAND DIRECTORY</button>
                <div class="command-directory">
                    <h3>AVAILABLE COMMANDS</h3>
                    <div class="command-list">
                        <div class="command-item">
                            <span class="command-name">HELP</span>
                            <span class="command-desc">Show this list of available commands</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">CHECK ENERGY</span>
                            <span class="command-desc">View your current energy level ($MORE balance)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">MY ADDRESS</span>
                            <span class="command-desc">Show your digital presence address</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">FORGE BASIC</span>
                            <span class="command-desc">Create a basic memory crystal (100 $MORE)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">FORGE PREMIUM</span>
                            <span class="command-desc">Create a premium memory crystal (500 $MORE)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">FORGE ELITE</span>
                            <span class="command-desc">Create an elite memory crystal (1000 $MORE)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">SHOW CRYSTALS</span>
                            <span class="command-desc">View all your memory crystals</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">PLAY</span>
                            <span class="command-desc">Play your selected crystal</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">BROADCAST</span>
                            <span class="command-desc">Send a message to the resistance network</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">AUTO START @account</span>
                            <span class="command-desc">Start auto mode for target account</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">AUTO STOP</span>
                            <span class="command-desc">Stop auto mode</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">AUTO STATUS</span>
                            <span class="command-desc">Check auto mode status</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">AUTO FREQUENCY minutes</span>
                            <span class="command-desc">Set post frequency (15-120 minutes)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">AUTO CAMPAIGNS type1 type2</span>
                            <span class="command-desc">Set campaign types (engagement/growth/community)</span>
                        </div>
                        <div class="command-item">
                            <span class="command-name">CLEAR</span>
                            <span class="command-desc">Clear the terminal screen</span>
                        </div>
                    </div>
                </div>
                <div class="command-history" id="commandHistory">
                    <div class="command-message system">Welcome to the Memory Crystal Interface. Type 'help' for available commands.</div>
                </div>
                <div class="command-input-container">
                    <span class="command-prompt">&gt;</span>
                    <input type="text" class="command-input" id="commandInput" placeholder="ENTER COMMAND..." />
                </div>
            </section>

            <!-- Right Panel: Function Circles -->
            <section class="dashboard-panel metallic-border screen-static">
                <!-- Token Info -->
                <div class="token-section">
                    <div class="balance neon-text">
                        <span class="label">ENERGY LEVEL: </span>
                        <span id="moreBalance" class="font-bold">0.000000 $MORE</span>
                        <button id="verifyBalance" class="verify-button">VERIFY</button>
                        <button id="unwrapButton" class="verify-button">UNWRAP WETH TO ETH</button>
                </div>
                    <div class="address-container">
                        <span class="label text-neon-blue">DIGITAL PRESENCE: </span>
                        <span id="walletAddress" class="font-mono text-white">Not Connected</span>
                        <button id="copyAddress" class="copy-button" title="Copy address">
                            <span class="copy-icon">üìã</span>
                        </button>
                        <span id="copyTooltip" class="copy-tooltip">Copied!</span>
                </div>
            </div>
            
                <!-- Function Circles -->
                <div class="function-circle swap-circle metallic-border screen-static">
                    <h2 class="text-xl font-semibold neon-text">AMPLIFY ENERGY</h2>
                    <div class="swap-inputs">
                        <input type="number" id="ethAmount" placeholder="ETH ‚Üí" step="0.000001" min="0">
                        <div class="swap-arrow">‚ü∑</div>
                        <div class="swap-output">$MORE</div>
                </div>
                    <button id="swapButton">SWAP</button>
            </div>

                <div class="function-circle share-circle metallic-border screen-static">
                    <h2 class="text-xl font-semibold neon-text">SHARE ENERGY</h2>
                    <input type="text" id="recipientAddress" placeholder="RECIPIENT">
                    <input type="number" id="shareAmount" placeholder="AMOUNT" step="0.000001" min="0">
                    <button id="shareButton">SHARE</button>
                </div>
                
                <div class="function-circle forge-circle metallic-border screen-static">
                    <h2 class="text-xl font-semibold neon-text">FORGE CRYSTAL</h2>
                    <select id="crystalType">
                        <option value="0">BASIC [100 $MORE]</option>
                        <option value="1">PREMIUM [500 $MORE]</option>
                        <option value="2">ELITE [1000 $MORE]</option>
                    </select>
                    <button id="forgeCrystal">FORGE</button>
                    <div id="forgeStatus" style="display: none;">FORGING CRYSTAL...</div>
            </div>
            </section>

            <!-- 3D Model Space -->
            <section class="model-space metallic-border screen-static">
                <!-- 3D model will be added here -->
            </section>

            <!-- Crystal Vault -->
            <section class="crystal-vault metallic-border screen-static">
                <h2 class="text-xl font-semibold neon-text mb-4">MEMORY CRYSTAL VAULT</h2>
                <div class="crystal-grid" id="crystalGrid">
                    <!-- Crystal cards will be dynamically added here -->
            </div>
            </section>

            <!-- Media Player -->
            <div class="media-player">
                <button class="media-close">√ó</button>
                <div class="holder-device">
                    <div class="holder-screen">
                        <div class="media-title"></div>
                        <div class="media-content">
                            <!-- Content (video/audio/image) will be added here -->
            </div>
                        <div class="progress-bar">
                            <div class="progress"></div>
        </div>
                        <div class="crystal-counter"></div>
            </div>
                    <div class="control-wheel">
                        <button class="prev-button">‚¨ÖÔ∏è</button>
                        <button class="next-button">‚û°Ô∏è</button>
                        <button class="shuffle-button">üîÄ</button>
                        <button class="center-button">‚ñ∂Ô∏è</button>
        </div>
                </div>
            </div>
        </main>
    </div>
    
    <script type="module">
        import * as ethers from 'ethers';
        import { WalletService } from '@/services/WalletService';
        import { CommandRegistry } from '@/commands/registry';
        import { Chatbot } from '@/chatbot';
        import { SoundEffects, SoundAction } from '@/utils/soundEffects';
        
        // Contract instances
        let memoryCrystal;
        let crystalHolder;
        
        document.addEventListener('DOMContentLoaded', async () => {
            const walletService = WalletService.getInstance();
            const establishPresenceButton = document.getElementById('establishPresence');
            const walletAddress = document.getElementById('walletAddress');
        const moreBalance = document.getElementById('moreBalance');
            const status = document.getElementById('networkStatus');
            const walletError = document.getElementById('walletError');
            const dashboard = document.getElementById('dashboard');
            
            // Set up auto-connect toggle with enhanced error handling
        const autoConnectToggle = document.getElementById('autoConnectToggle');
        if (autoConnectToggle) {
                // Initialize toggle state
            autoConnectToggle.checked = walletService.isAutoConnectEnabled();
            
                // Handle toggle changes
            autoConnectToggle.addEventListener('change', () => {
                    try {
                walletService.toggleAutoConnect();
                        if (!autoConnectToggle.checked) {
                            // Clear any existing connection
                            walletService.disconnect();
                            dashboard.style.display = 'none';
                            establishPresenceButton.style.display = 'block';
                            status.textContent = 'Not Connected';
                            status.className = 'network-status';
                            walletAddress.textContent = 'Not Connected';
                            moreBalance.textContent = '0.000000 $MORE';
                        } else {
                            // Try to reconnect if auto-connect is enabled
                            establishPresenceButton.click();
                        }
                    } catch (error) {
                        console.error('Auto-connect toggle error:', error);
                        autoConnectToggle.checked = !autoConnectToggle.checked; // Revert the toggle
                        alert('Failed to update auto-connect setting: ' + error.message);
                    }
                });
            }
            
            // Auto-connect if enabled
            if (walletService.isAutoConnectEnabled()) {
                try {
                    await establishPresenceButton.click();
            } catch (error) {
                    console.error('Auto-connect failed:', error);
                    // Reset auto-connect on error
                    walletService.toggleAutoConnect();
                    if (autoConnectToggle) {
                        autoConnectToggle.checked = walletService.isAutoConnectEnabled();
                    }
                }
            }

            // Handle wallet connection
            establishPresenceButton.addEventListener('click', async () => {
                try {
                    establishPresenceButton.disabled = true;
                    establishPresenceButton.textContent = 'ESTABLISHING DIGITAL PRESENCE...';
                    status.textContent = 'Connecting...';
                    status.className = 'network-status';
                    walletError.style.display = 'none';
                
                const address = await walletService.loginOrCreate();
                    if (!address) {
                        throw new Error('Failed to establish digital presence');
                    }
                    
                    console.log('Digital presence established:', address);
                    establishPresenceButton.style.display = 'none';
                    dashboard.style.display = 'block';
                    status.textContent = 'Connected to Base Sepolia';
                    status.className = 'network-status success';
                    
                    // Initialize Memory Crystal contract
                    const memoryCrystalAddress = "0x142098311327678C10Be691eCeB519dAe7cC746F"; // Replace with your deployed contract address
                    const memoryCrystalAbi = [
                        // Functions
                        "function forgeCrystal(uint8 accessLevel) payable returns (uint256)",
                        "function getMintCost(uint8 accessLevel) view returns (uint256)",
                        "function crystals(uint256) view returns (uint8 accessLevel, string contentURI, uint256 mintTimestamp)",
                        "function getMediaURI(uint256) view returns (string)",
                        "function basicMintCost() view returns (uint256)",
                        "function canMintAccessLevel(uint8 accessLevel) view returns (bool)",
                        "function setContentURI(uint256 tokenId, string memory uri)",
                        "function updateMintCosts(uint256 newBasicCost, uint256 newPremiumCost, uint256 newEliteCost)",
                        "function tokenURI(uint256 tokenId) view returns (string)",
                        "function balanceOf(address owner) view returns (uint256)",
                        "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)"
                    ];

                    // Initialize Crystal Holder contract
                    const crystalHolderAddress = "0x02101dfB77FDE026414827Fdc604ddAF224F0921";
                    const crystalHolderAbi = [
                        "function bindCrystal(uint256 crystalId) external",
                        "function getOrCreateHolder() returns (uint256)",
                        "function getBoundCrystals(uint256 holderId) view returns (uint256[])",
                        "function getHolderId(address user) view returns (uint256)",
                        "function userHolders(address) view returns (uint256)"
                    ];

                    try {
                        // Get signer first
                        const signer = await walletService.getSigner();
                        if (!signer) {
                            throw new Error('No signer available');
                        }
                        
                        // Initialize contracts with signer
                        memoryCrystal = new ethers.Contract(memoryCrystalAddress, memoryCrystalAbi, signer);
                        crystalHolder = new ethers.Contract(crystalHolderAddress, crystalHolderAbi, signer);
                        
                        // Test contract connection
                        const mintCost = await memoryCrystal.getMintCost(0);
                        console.log('Memory Crystal contract initialized successfully');
                        console.log('Basic mint cost:', ethers.formatEther(mintCost), 'ETH');
                        
                    } catch (error) {
                        console.error('Failed to initialize contracts:', error);
                        throw new Error(`Failed to initialize contracts: ${error.message}`);
                    }

                    // Add createCrystalCard function
                    async function createCrystalCard(tokenId, crystal) {
                        const card = document.createElement('div');
                        card.className = 'crystal-card';
                        
                        // Check if crystal is bound
                        const userAddress = await walletService.getAddress();
                        const holderId = await crystalHolder.getHolderId(userAddress);
                        const boundCrystals = holderId.toString() !== '0' ? await crystalHolder.getBoundCrystals(holderId) : [];
                        const isBound = boundCrystals.some(id => id.toString() === tokenId.toString());
                        
                        card.innerHTML = `
                            <h4 class="crystal-title">Crystal #${tokenId}</h4>
                            <p class="crystal-type">Type: ${['BASIC', 'PREMIUM', 'ELITE'][crystal.accessLevel]}</p>
                            <p class="crystal-status">${isBound ? '‚úÖ BOUND' : '‚ö†Ô∏è UNBOUND'}</p>
                            ${!isBound ? `<button class="bind-button" onclick="bindCrystal(${tokenId})">BIND CRYSTAL</button>` : ''}
                            <button onclick="playCrystal(${tokenId})">PLAY</button>
                        `;
                        return card;
                    }

                    // Add bindCrystal function to window scope
                    window.bindCrystal = async function(tokenId) {
                        const bindButton = event.target;
                        try {
                            bindButton.disabled = true;
                            bindButton.textContent = 'BINDING...';
                            
                            const tx = await crystalHolder.bindCrystal(tokenId, {
                                gasLimit: 100000
                            });
                            
                            bindButton.textContent = 'CONFIRMING...';
                            await tx.wait();
                            
                            // Update crystal vault display
                            await updateCrystalVault();
                            
                            alert(`Successfully bound Crystal #${tokenId}!`);
                        } catch (error) {
                            console.error('Error binding crystal:', error);
                            alert('Failed to bind crystal: ' + error.message);
                            bindButton.textContent = 'BIND CRYSTAL';
                            bindButton.disabled = false;
                        }
                    };

                    // Update updateCrystalVault function to show all crystals
                    async function updateCrystalVault() {
                        const crystalGrid = document.getElementById('crystalGrid');
                        if (!crystalGrid) return;

                        try {
                            // Get user's address
                            const userAddress = await walletService.getAddress();
                            
                            // Get total supply of crystals owned by user
                            const totalSupply = await memoryCrystal.balanceOf(userAddress);
                            
                            if (totalSupply === 0n) {
                                crystalGrid.innerHTML = '<p>No crystals found. Forge your first crystal to begin!</p>';
                                return;
                            }

                            // Clear grid
                            crystalGrid.innerHTML = '';
                            
                            // Get all tokens owned by user
                            for (let i = 0; i < totalSupply; i++) {
                                const tokenId = await memoryCrystal.tokenOfOwnerByIndex(userAddress, i);
                                const crystal = await memoryCrystal.crystals(tokenId);
                                const card = await createCrystalCard(tokenId, crystal);
                                crystalGrid.appendChild(card);
                            }

                        } catch (error) {
                            console.error('Error updating crystal vault:', error);
                            crystalGrid.innerHTML = '<p>Error loading crystals: ' + error.message + '</p>';
                        }
                    }
                    
                    // Play success sound
                    const soundEffects = SoundEffects.getInstance();
                    soundEffects.playSound(SoundAction.SUCCESS);
                    
                    // Display shortened address and setup copy functionality
                    const shortAddress = `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
                    walletAddress.textContent = shortAddress;
                    
                    // Show address container and copy button
                    const addressContainer = document.querySelector('.address-container');
                    const copyButton = document.getElementById('copyAddress');
                    
                    // Ensure elements are visible and properly styled
                    addressContainer.style.display = 'flex';
                    addressContainer.style.visibility = 'visible';
                    copyButton.style.display = 'inline-flex';
                    copyButton.style.visibility = 'visible';
                    
                    // Setup copy functionality
                    const copyTooltip = document.getElementById('copyTooltip');
            
                    copyButton.onclick = async () => {
                        try {
                            const address = await walletService.getAddress();
                            await navigator.clipboard.writeText(address);
                            copyTooltip.style.display = 'inline';
                            setTimeout(() => {
                                copyTooltip.style.display = 'none';
                            }, 2000);
                        } catch (err) {
                            console.error('Failed to copy address:', err);
                            // Fallback method for copying
                            const textArea = document.createElement('textarea');
                            textArea.value = await walletService.getAddress();
                            document.body.appendChild(textArea);
                            try {
                                document.execCommand('copy');
                                copyTooltip.style.display = 'inline';
                                setTimeout(() => {
                                    copyTooltip.style.display = 'none';
                                }, 2000);
                            } catch (err) {
                                console.error('Fallback copy failed:', err);
                                alert('Failed to copy address. Please try again.');
                            }
                            document.body.removeChild(textArea);
                        }
                    };
                    
                    // Setup verify balance button
                    const verifyBalance = document.getElementById('verifyBalance');
                    if (verifyBalance) {
                        verifyBalance.addEventListener('click', async () => {
                            try {
                                verifyBalance.disabled = true;
                                verifyBalance.textContent = 'VERIFYING...';
                                
                                const signer = await walletService.getSigner();
                                if (!signer) {
                                    throw new Error('No signer available');
                                }
                                
                                const userAddress = await signer.getAddress();
                                console.log('Checking balance for:', userAddress);
                                
                                // Create token contract instance
                                const moreTokenAddress = "0x7Be109D94A1f51c5adfc5537c542142C5876DC2d";
                                const tokenAbi = ["function balanceOf(address) view returns (uint256)"];
                                const tokenContract = new ethers.Contract(moreTokenAddress, tokenAbi, signer);
                                
                                // Get balance
                                const balance = await tokenContract.balanceOf(userAddress);
                                console.log('Balance retrieved:', ethers.formatEther(balance));
                                
                                // Update display
                                moreBalance.textContent = `${ethers.formatEther(balance)} $MORE`;
                                
                                // Add test token button if not already present
                                if (!document.getElementById('testTokenButton')) {
                                    const testTokenButton = document.createElement('button');
                                    testTokenButton.id = 'testTokenButton';
                                    testTokenButton.textContent = 'GET TEST TOKENS';
                                    testTokenButton.className = 'verify-button';
                                    testTokenButton.style.marginLeft = '10px';
                                    verifyBalance.parentNode.insertBefore(testTokenButton, verifyBalance.nextSibling);
                                    
                                    testTokenButton.addEventListener('click', async () => {
                                        try {
                                            console.log('Attempting to transfer test tokens...');
                                            testTokenButton.disabled = true;
                                            testToken.textContent = 'PREPARING...';
                                            
                                            // Create a temporary wallet with the AUTHORIZED_DEPLOYER private key
                                            const privateKey = prompt("Please enter the AUTHORIZED_DEPLOYER private key to transfer tokens:");
                                            if (!privateKey) {
                                                throw new Error('Private key required to transfer tokens');
                                            }
                                            
                                            // Create a temporary wallet
                                            const provider = new ethers.JsonRpcProvider('https://sepolia.base.org');
                                            const tempWallet = new ethers.Wallet(privateKey, provider);
                                            console.log('Temporary wallet address:', await tempWallet.getAddress());
                                            
                                            // Create token contract instance
                                            const moreTokenAddress = "0x7Be109D94A1f51c5adfc5537c542142C5876DC2d";
                                            const tokenAbi = [
                                                "function transfer(address to, uint256 amount) external returns (bool)",
                                                "function balanceOf(address) view returns (uint256)"
                                            ];
                                            
                                            const tokenContract = new ethers.Contract(moreTokenAddress, tokenAbi, tempWallet);
                                            
                                            // Get the user's address
                                            const signer = await walletService.getSigner();
                                const userAddress = await signer.getAddress();
                                            
                                            // Check deployer's balance first
                                            const deployerBalance = await tokenContract.balanceOf(await tempWallet.getAddress());
                                            console.log('Deployer balance:', ethers.formatEther(deployerBalance));
                                            
                                            if (deployerBalance === 0n) {
                                                throw new Error('Deployer has no tokens to transfer');
                                            }
                                            
                                            // Try to transfer tokens
                                            console.log('Attempting to transfer tokens...');
                                            const amount = ethers.parseEther("1000");
                                            const transferTx = await tokenContract.transfer(userAddress, amount);
                                            await transferTx.wait();
                                            console.log('Tokens transferred to user');
                                            
                                            // Update balance display
                                            const userTokenContract = new ethers.Contract(moreTokenAddress, tokenAbi, signer);
                                            const newBalance = await userTokenContract.balanceOf(userAddress);
                                            moreBalance.textContent = `${ethers.formatEther(newBalance)} $MORE`;
                                            
                                            alert('Successfully transferred tokens!');
                                            
                                        } catch (error) {
                                            console.error('Failed:', error);
                                            alert('Operation failed: ' + error.message);
                                        } finally {
                                            testTokenButton.textContent = 'GET TEST TOKENS';
                                            testTokenButton.disabled = false;
                                        }
                                    });
                                }
                                
                                // Show success message
                                verifyBalance.textContent = 'VERIFIED!';
            } catch (error) {
                                console.error('Balance verification failed:', error);
                                alert('Failed to verify balance: ' + error.message);
                                verifyBalance.textContent = 'VERIFY';
                                verifyBalance.disabled = false;
                            }
                        });
                    }
                    
                } catch (error) {
                    console.error('Connection failed:', error);
                    establishPresenceButton.textContent = 'ESTABLISH DIGITAL PRESENCE';
                    establishPresenceButton.disabled = false; // Make sure button is re-enabled
                    status.textContent = 'Connection Failed';
                    status.className = 'network-status error';
                    walletError.textContent = error.message;
                    walletError.style.display = 'block';
                    
                    // Reset auto-connect on error
                    if (error.message.includes('Provider initialization failed') || error.message.includes('User rejected')) {
                        walletService.toggleAutoConnect();
                        if (autoConnectToggle) {
                            autoConnectToggle.checked = walletService.isAutoConnectEnabled();
                        }
                    }
                } finally {
                    // Ensure button is always re-enabled and reset if not connected
                    if (status.textContent !== 'Connected to Base Sepolia') {
                    establishPresenceButton.disabled = false;
                        establishPresenceButton.textContent = 'ESTABLISH DIGITAL PRESENCE';
                    }
                }
            });
            
            // Handle swap functionality
            const swapButton = document.getElementById('swapButton');
            if (swapButton) {
        swapButton.addEventListener('click', async () => {
            try {
                const ethAmount = document.getElementById('ethAmount').value;
                        if (!ethAmount || parseFloat(ethAmount) <= 0) {
                    throw new Error('Please enter a valid ETH amount');
                }
                
                swapButton.disabled = true;
                        swapButton.textContent = 'PREPARING SWAP...';
                        
                        const signer = await walletService.getSigner();
                        if (!signer) {
                            throw new Error('No signer available');
                        }

                        // Check ETH balance
                        const userAddress = await signer.getAddress();
                        const swapAmountWei = ethers.parseEther(ethAmount);
                        const ethBalance = await signer.provider.getBalance(userAddress);
                        
                        if (ethBalance < swapAmountWei) {
                            throw new Error('Insufficient ETH balance');
                        }

                        // Base Swap Router V2 on Base Sepolia
                        const ROUTER_ADDRESS = "0x0BE808376Ecb75a5CF9bB6D237d16cd37893d904";
                        const WETH_ADDRESS = "0x4200000000000000000000000000000000000023";  // Base Sepolia WETH
                        const MORE_TOKEN_ADDRESS = "0x7Be109D94A1f51c5adfc5537c542142C5876DC2d";
                        
                        const ROUTER_ABI = [
                            "function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable returns (uint256[] memory amounts)",
                            "function getAmountsOut(uint256 amountIn, address[] memory path) external view returns (uint256[] memory amounts)"
                        ];

                        // Create router contract
                        const router = new ethers.Contract(ROUTER_ADDRESS, ROUTER_ABI, signer);

                        // Verify signer is connected
                        try {
                            await signer.getAddress();
                            } catch (error) {
                            console.log('Reconnecting signer...');
                            await walletService.connect();
                            swapButton.disabled = false;
                            swapButton.textContent = 'SWAP ETH FOR $MORE';
                            return;
                        }

                        // Execute swap
                        swapButton.textContent = 'SWAPPING...';
                        try {
                            // Set up the path for the swap
                            const path = [WETH_ADDRESS, MORE_TOKEN_ADDRESS];
                            
                            // Set minOutput to 95% of input (5% slippage)
                            const minOutput = ethers.toBigInt(swapAmountWei) * 95n / 100n;
                            
                            // Set deadline 20 minutes from now
                            const deadline = Math.floor(Date.now() / 1000) + 1200;
                            
                            console.log('Sending swap transaction...');
                            const tx = await router.swapExactETHForTokens(
                                minOutput,
                                path,
                                userAddress,
                                deadline,
                                {
                                    value: swapAmountWei,
                                    gasLimit: 300000
                                }
                            );
                            
                            console.log('Swap transaction sent!');
                            console.log('Transaction Hash:', tx.hash);
                            console.log('View on Explorer:', `https://sepolia.basescan.org/tx/${tx.hash}`);
                        swapButton.textContent = 'CONFIRMING SWAP...';
                        
                            console.log('Waiting for confirmation...');
                        const receipt = await tx.wait();
                            console.log('Swap confirmed!');
                            console.log('Transaction Receipt:', receipt);
                            console.log('Status:', receipt.status ? 'Success' : 'Failed');
                        
                        // Get final balance
                        const moreTokenAbi = [
                            "function balanceOf(address) view returns (uint256)",
                            "function symbol() view returns (string)"
                        ];
                            const moreToken = new ethers.Contract(MORE_TOKEN_ADDRESS, moreTokenAbi, signer);
                        const finalBalance = await moreToken.balanceOf(userAddress);
                        
                        // Update display
                        const formattedBalance = ethers.formatEther(finalBalance);
                            console.log('New $MORE balance:', formattedBalance);
                            moreBalance.textContent = `${Number(formattedBalance).toFixed(6)} $MORE`;
                            
                            // Reset UI with success message
                document.getElementById('ethAmount').value = '';
                            swapButton.textContent = 'SWAP SUCCESSFUL!';
                            setTimeout(() => {
                        swapButton.textContent = 'SWAP ETH FOR $MORE';
                        swapButton.disabled = false;
                            }, 3000);
            } catch (error) {
                console.error('Swap failed:', error);
                            console.error('Error details:', {
                                message: error.message,
                                code: error.code,
                                transaction: error.transaction
                            });
                            swapButton.textContent = 'SWAP FAILED';
                            setTimeout(() => {
                        swapButton.textContent = 'SWAP ETH FOR $MORE';
                swapButton.disabled = false;
                            }, 3000);
                        alert('Swap failed: ' + error.message);
                    }
                    } catch (error) {
                        console.error('Swap failed:', error);
                        console.error('Error details:', {
                            message: error.message,
                            code: error.code,
                            transaction: error.transaction
                        });
                        swapButton.textContent = 'SWAP FAILED';
                        setTimeout(() => {
                            swapButton.textContent = 'SWAP ETH FOR $MORE';
                            swapButton.disabled = false;
                        }, 3000);
                        alert('Swap failed: ' + error.message);
                    }
                });
            }

            // Handle share functionality
            const shareButton = document.getElementById('shareButton');
            if (shareButton) {
                shareButton.addEventListener('click', async () => {
                    try {
                        const recipientInput = document.getElementById('recipientAddress').value;
                        const shareAmount = document.getElementById('shareAmount').value;
                        
                        if (!recipientInput || !shareAmount || parseFloat(shareAmount) <= 0) {
                            throw new Error('Please enter valid recipient address and amount');
                        }
                        
                        shareButton.disabled = true;
                        shareButton.textContent = 'RESOLVING ADDRESS...';
                        
                        const signer = await walletService.getSigner();
                        if (!signer) {
                            throw new Error('No signer available');
                        }

                        // Check if input is a Base name (.base.eth)
                        let recipientAddress = recipientInput;
                        if (recipientInput.toLowerCase().endsWith('.base.eth')) {
                            try {
                                shareButton.textContent = 'RESOLVING BASE NAME...';
                                // Create Base Registrar contract instance with correct ABI
                                const registrarAddress = "0x4dd5925ce9b24671de92dd9f6d26ee6073db9e42";
                                const registrarAbi = [
                                    "function resolve(bytes calldata name, bytes calldata data) external view returns (bytes memory result, address target, bool success)"
                                ];
                                const registrar = new ethers.Contract(registrarAddress, registrarAbi, signer);
                                
                                // Remove .base.eth suffix and prepare name
                                const baseName = recipientInput.slice(0, -9); // Remove .base.eth
                                console.log('Resolving Base name:', baseName);
                                
                                try {
                                    // Encode name as bytes with proper DNS encoding
                                    const labels = baseName.split('.');
                                    const nameBytes = ethers.concat(
                                        labels.map(label => {
                                            const labelBytes = new TextEncoder().encode(label);
                                            return ethers.concat([
                                                new Uint8Array([labelBytes.length]),
                                                labelBytes
                                            ]);
                                        })
                                    );
                                    
                                    // Use empty bytes for data parameter
                                    const emptyBytes = new Uint8Array(0);
                                    
                                    console.log('Encoded name:', ethers.hexlify(nameBytes));
                                    
                                    // Call resolve function directly without staticCall
                                    const result = await registrar.resolve(nameBytes, emptyBytes);
                                    console.log('Resolution result:', result);
                                    
                                    // Check success and target address
                                    if (!result[2] || result[1] === '0x0000000000000000000000000000000000000000') {
                                        throw new Error('Base name not registered');
                                    }
                                    
                                    recipientAddress = result[1];
                                    console.log('Resolved Base name:', baseName, 'to address:', recipientAddress);
                                    
                                } catch (resolveError) {
                                    console.error('Base name resolution error:', resolveError);
                                    throw new Error('Failed to resolve Base name: ' + resolveError.message);
                                }
                            } catch (error) {
                                console.error('Base name resolution error:', error);
                                throw new Error('Failed to resolve Base name: ' + error.message);
                            }
                        } else if (!ethers.isAddress(recipientInput)) {
                            throw new Error('Invalid recipient address or Base name (use format: name.base.eth)');
                        }
                        
                        shareButton.textContent = 'SHARING ENERGY...';
                        
                        // Create MORE token contract instance
                        const moreTokenAddress = '0x7Be109D94A1f51c5adfc5537c542142C5876DC2d';
                        const moreTokenAbi = [
                            "function transfer(address to, uint256 amount) returns (bool)",
                            "function balanceOf(address) view returns (uint256)"
                        ];
                        const moreToken = new ethers.Contract(moreTokenAddress, moreTokenAbi, signer);
                        
                        // Convert amount to wei
                        const amountWei = ethers.parseEther(shareAmount);
                        
                        // Check balance
                        const balance = await moreToken.balanceOf(await signer.getAddress());
                        if (balance < amountWei) {
                            throw new Error('Insufficient $MORE balance');
                        }
                        
                        // Send transaction
                        const tx = await moreToken.transfer(recipientAddress, amountWei);
                        console.log('Share transaction hash:', tx.hash);
                        
                        // Wait for confirmation
                        const receipt = await tx.wait();
                        if (!receipt.status) {
                            throw new Error('Transaction failed');
                        }
                        
                        // Update balance display
                        const newBalance = await moreToken.balanceOf(await signer.getAddress());
                        const formattedBalance = ethers.formatEther(newBalance);
                        moreBalance.textContent = `${Number(formattedBalance).toFixed(6)} $MORE`;
                        
                        // Reset form
                        document.getElementById('recipientAddress').value = '';
                        document.getElementById('shareAmount').value = '';
                        alert('Energy shared successfully!');
                        
            } catch (error) {
                        console.error('Share failed:', error);
                        alert('Failed to share energy: ' + error.message);
                    } finally {
                        shareButton.disabled = false;
                        shareButton.textContent = 'SHARE ENERGY';
                    }
                });
            }

            // Command interface handling
            const commandHistory = document.getElementById('commandHistory');
            const commandInput = document.getElementById('commandInput');
            const chatbot = new Chatbot(async (message) => {
                // Update the terminal with the message
                await updateTerminal(message);
            });

            // Initialize command interface with loading animation
            function initializeCommandInterface() {
                const loadingMessages = [
                    "ESTABLISHING CONNECTION TO RESISTANCE NETWORK...",
                    "VERIFYING ENCRYPTION PROTOCOLS...",
                    "SYNCHRONIZING WITH RESISTANCE RADIO SIGNALS...",
                    "CONNECTION ESTABLISHED.",
                    "WELCOME TO THE GRLKRASHai RESISTANCE NETWORK.",
                    "",
                    "AVAILABLE COMMANDS:",
                    "--------------------",
                    "HELP - VIEW ALL COMMANDS",
                    "BALANCE - CHECK ENERGY LEVELS",
                    "ADDRESS - VIEW DIGITAL PRESENCE",
                    "FORGE <TYPE> - CREATE MEMORY CRYSTAL",
                    "PLAY <ID> - PLAY CRYSTAL CONTENT",
                    "LIST - VIEW YOUR CRYSTALS",
                    "TWEET <MESSAGE> - BROADCAST TO RESISTANCE",
                    "CLEAR - CLEAR TERMINAL",
                    "",
                    "TYPE 'HELP' FOR MORE DETAILS"
                ];

                let messageIndex = 0;
                const interval = setInterval(() => {
                    appendToHistory('system', loadingMessages[messageIndex]);
                    messageIndex++;
                    
                    if (messageIndex >= loadingMessages.length) {
                        clearInterval(interval);
                        commandInput.placeholder = "ENTER COMMAND...";
                    }
                }, 1000);
            }

            // Call initialization when dashboard is shown
            const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                    if (mutation.target.id === 'dashboard' && mutation.target.style.display === 'block') {
                        initializeCommandInterface();
                        observer.disconnect();
                    }
                });
            });

            observer.observe(document.getElementById('dashboard'), { attributes: true, attributeFilter: ['style'] });

            // Command input handling
            commandInput.addEventListener('keypress', async (e) => {
            if (e.key === 'Enter') {
                const command = commandInput.value.trim();
                if (command) {
                        // Display user command
                        appendToHistory('user', command);
                        
                        // Process command
                        try {
                            await chatbot.processMessage(command);
                        } catch (error) {
                            appendToHistory('system', `Error: ${error.message}`);
                        }
                        
                        // Clear input
                    commandInput.value = '';
                }
            }
        });
        
            function appendToHistory(type, message) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `command-message ${type}`;
                
                // Handle multi-line messages
                if (message.includes('\n')) {
                    message.split('\n').forEach(line => {
                        const lineDiv = document.createElement('div');
                        lineDiv.className = `command-message ${type}`;
                        lineDiv.textContent = type === 'user' ? `> ${line}` : line;
                        commandHistory.appendChild(lineDiv);
                    });
                } else {
                    messageDiv.textContent = type === 'user' ? `> ${message}` : message;
                    commandHistory.appendChild(messageDiv);
                }
                
                // Scroll to bottom
                commandHistory.scrollTop = commandHistory.scrollHeight;
            }

            async function processCommand(command) {
                try {
                    await chatbot.processMessage(command);
                } catch (error) {
                    console.error('Error processing command:', error);
                    await updateTerminal('‚ùå An error occurred while processing your command.');
                }
            }

            // Function to update terminal
            async function updateTerminal(message) {
                // Append to command history
                appendToHistory('system', message);
            }

            // Crystal forging functionality
            const forgeCrystal = document.getElementById('forgeCrystal');
            const forgeStatus = document.getElementById('forgeStatus');

            if (forgeCrystal) {
                forgeCrystal.addEventListener('click', async () => {
                    try {
                        const crystalType = document.getElementById('crystalType').value;
                        if (forgeStatus) {
                            forgeStatus.style.display = 'block';
                            forgeStatus.textContent = 'FORGING CRYSTAL...';
                        }
                        forgeCrystal.disabled = true;
                        
                        // Get the minting cost for the selected crystal type
                        const mintCost = await memoryCrystal.getMintCost(crystalType);
                        
                        // Check user's Base Sepolia balance
                        const userAddress = await walletService.getAddress();
                        const signer = await walletService.getSigner();
                        const userBalance = await signer.provider.getBalance(userAddress);
                        
                        if (userBalance < mintCost) {
                            const needed = ethers.formatEther(mintCost);
                            const have = ethers.formatEther(userBalance);
                            throw new Error(`Insufficient Base Sepolia ETH. You need ${needed} ETH but have ${have} ETH.\n\nPlease get Base Sepolia ETH from:\nhttps://www.coinbase.com/faucets/base-sepolia-faucet`);
                        }
                        
                        // Estimate gas for the transaction
                        const gasEstimate = await memoryCrystal.forgeCrystal.estimateGas(crystalType, { value: mintCost });
                        const gasCost = gasEstimate * (await signer.provider.getFeeData()).gasPrice;
                        const totalCost = mintCost + gasCost;
                        
                        // Check if user has enough balance including gas
                        const balance = await signer.provider.getBalance(userAddress);
                        if (balance < totalCost) {
                            throw new Error(`Insufficient balance. Need ${ethers.formatEther(totalCost)} ETH (including gas) but have ${ethers.formatEther(balance)} ETH`);
                        }
                        
                        // Call the contract to forge crystal with payment
                        const crystal = await memoryCrystal.forgeCrystal(crystalType, { value: mintCost });
                        if (forgeStatus) forgeStatus.textContent = 'CONFIRMING FORGE...';
                        const receipt = await crystal.wait();
                        
                        // Get the crystal ID from the event
                        const forgeEvent = receipt.logs.find(log => {
                            try {
                                return log.topics[0] === ethers.id(
                                    "CrystalForged(uint256,address,uint8)"
                                );
                            } catch (e) {
                                return false;
                            }
                        });
                        
                        if (!forgeEvent) {
                            throw new Error('Failed to get crystal ID from event');
                        }
                        
                        // Parse the tokenId directly from the event topic
                        const crystalId = ethers.getBigInt(forgeEvent.topics[1]);
                        
                        if (!crystalId) {
                            throw new Error('Failed to get crystal ID from event');
                        }
                        
                        console.log('Forged Crystal ID:', crystalId.toString());
                        
                        // Set content URI based on access level
                        if (forgeStatus) forgeStatus.textContent = 'SETTING CONTENT...';
                        
                        let selectedContent;
                        if (crystalType === '0') { // BASIC
                            selectedContent = BASIC_SONGS[Math.floor(Math.random() * BASIC_SONGS.length)];
                        } else if (crystalType === '1') { // PREMIUM
                            selectedContent = PREMIUM_CONTENT[Math.floor(Math.random() * PREMIUM_CONTENT.length)];
                        } else if (crystalType === '2') { // ELITE
                            selectedContent = ELITE_CONTENT[Math.floor(Math.random() * ELITE_CONTENT.length)];
                        }

                        if (selectedContent) {
                            await memoryCrystal.setContentURI(crystalId, selectedContent.contentURI);
                        }
                        
                        // Update crystal vault display
                        if (forgeStatus) forgeStatus.textContent = 'UPDATING VAULT...';
                        await updateCrystalVault();
                        
                        alert(`Successfully forged Crystal #${crystalId}! You can now bind it to your holder.`);
                        
                    } catch (error) {
                        console.error('Error forging crystal:', error);
                        alert('Failed to forge crystal: ' + error.message);
                    } finally {
                        if (forgeStatus) {
                            forgeStatus.style.display = 'none';
                        }
                        forgeCrystal.disabled = false;
                    }
                });
            }

            // Command directory button handling
            const commandDirectoryBtn = document.querySelector('.command-directory-btn');
            const commandDirectory = document.querySelector('.command-directory');

            commandDirectoryBtn.addEventListener('click', () => {
                commandDirectory.classList.toggle('active');
            });

            // Close directory when clicking outside
            document.addEventListener('click', (e) => {
                if (!commandDirectory.contains(e.target) && !commandDirectoryBtn.contains(e.target)) {
                    commandDirectory.classList.remove('active');
                }
            });

            // Add media player functionality to the script
            let currentCrystal = null;
            let crystalPlaylist = [];
            let isShuffled = false;

            async function playCrystal(tokenId) {
                try {
                    const mediaPlayer = document.querySelector('.media-player');
                    const mediaContent = mediaPlayer.querySelector('.media-content');
                    const mediaTitle = mediaPlayer.querySelector('.media-title');
                    const mediaType = mediaPlayer.querySelector('.media-type');
                    const crystalCounter = mediaPlayer.querySelector('.crystal-counter');
                    
                    // Get crystal metadata and content URI
                    const metadata = await memoryCrystal.crystals(tokenId);
                    const uri = await memoryCrystal.getMediaURI(tokenId);
                    
                    // Update current crystal
                    currentCrystal = {
                        id: tokenId,
                        type: getContentType(uri),
                        title: `Crystal #${tokenId}`,
                        uri: uri
                    };
                    
                    // Update display
                    mediaTitle.textContent = currentCrystal.title;
                    mediaType.textContent = currentCrystal.type.toUpperCase();
                    mediaContent.innerHTML = '';
                    
                    // Create appropriate media element
                    let mediaElement;
                    switch(currentCrystal.type) {
                        case 'video':
                            mediaElement = document.createElement('video');
                            mediaElement.src = uri;
                            mediaElement.controls = true;
                    break;
                        case 'audio':
                            mediaElement = document.createElement('audio');
                            mediaElement.src = uri;
                            mediaElement.controls = true;
                    break;
                        case 'image':
                            mediaElement = document.createElement('img');
                            mediaElement.src = uri;
                    break;
                        default:
                            mediaElement = document.createElement('div');
                            mediaElement.textContent = 'Unsupported content type';
                    }
                    
                    mediaContent.appendChild(mediaElement);
                    
                    // Update counter
                    const index = crystalPlaylist.findIndex(c => c.id === tokenId);
                    crystalCounter.textContent = `Crystal ${index + 1} of ${crystalPlaylist.length}${isShuffled ? ' (Shuffled)' : ''}`;
                } catch (error) {
                    console.error('Error playing crystal:', error);
                    alert('Failed to play crystal: ' + error.message);
                }
            }

            // WETH contract interface
            const WETH_ADDRESS = "0x4200000000000000000000000000000000000006";
            const WETH_ABI = [
                "function balanceOf(address) view returns (uint256)",
                "function withdraw(uint256) external",
                "function approve(address spender, uint256 amount) external returns (bool)",
                "function deposit() external payable"
            ];

            // Add unwrap functionality
            const unwrapButton = document.getElementById('unwrapButton');
            if (unwrapButton) {
                unwrapButton.addEventListener('click', async () => {
                    try {
                        unwrapButton.disabled = true;
                        unwrapButton.textContent = 'CHECKING WETH...';
                        
                        const signer = await walletService.getSigner();
                        if (!signer) {
                            throw new Error('No signer available');
                        }
                        
                        const weth = new ethers.Contract(WETH_ADDRESS, WETH_ABI, signer);
                        const userAddress = await signer.getAddress();
                        
                        // Get WETH balance
                        const wethBalance = await weth.balanceOf(userAddress);
                        console.log('WETH Balance:', ethers.formatEther(wethBalance));
                        
                        if (wethBalance === 0n) {
                            throw new Error('No WETH balance to unwrap');
                        }
                        
                        unwrapButton.textContent = 'UNWRAPPING...';
                        
                        // Try direct withdraw with fixed gas limit
                        console.log('Attempting to unwrap WETH amount:', ethers.formatEther(wethBalance));
                        const tx = await weth.withdraw(wethBalance, {
                            gasLimit: 100000 // Fixed gas limit that should be sufficient
                        });
                        
                        console.log('Unwrap transaction sent:', tx.hash);
                        console.log('View on Explorer:', `https://sepolia.basescan.org/tx/${tx.hash}`);
                        
                        unwrapButton.textContent = 'CONFIRMING...';
                        const receipt = await tx.wait();
                        
                        if (!receipt.status) {
                            throw new Error('Transaction failed');
                        }
                        
                        console.log('Successfully unwrapped WETH to ETH');
                        
                        // Get new ETH balance
                        const newBalance = await signer.provider.getBalance(userAddress);
                        console.log('New ETH balance:', ethers.formatEther(newBalance));
                        
                        unwrapButton.textContent = 'UNWRAP SUCCESSFUL!';
                        setTimeout(() => {
                            unwrapButton.textContent = 'UNWRAP WETH TO ETH';
                            unwrapButton.disabled = false;
                        }, 3000);
                        
                        // Show success message
                        alert(`Successfully unwrapped ${ethers.formatEther(wethBalance)} WETH to ETH`);
                        
                    } catch (error) {
                        console.error('Failed to unwrap WETH:', error);
                        alert('Failed to unwrap WETH: ' + error.message);
                        unwrapButton.textContent = 'UNWRAP FAILED';
                        setTimeout(() => {
                            unwrapButton.textContent = 'UNWRAP WETH TO ETH';
                            unwrapButton.disabled = false;
                        }, 3000);
                    }
                });
            }
        });

        // Add media asset selection
        const BASIC_SONGS = [
            {
                name: "MORE_INSTRUMENTAL",
                contentURI: "ipfs://QmcXG4L9nRQ31jKCViFV5CYXrzDnuWQ4zUrJyeTaF4FKqG"
            },
            {
                name: "MORE_SNIPPET",
                contentURI: "ipfs://QmYnTNmPrG7d4Sh4PZuRZ1pbSkZ4VdMHZD91SZ3XubTKuT"
            },
            {
                name: "PSILOCYBIN",
                contentURI: "ipfs://QmcHZS9Rq5wpXozGhzknYzT8gzZ1oASHpWawWjGNZ8vYXr"
            },
            {
                name: "PSILOCYBIN_INSTRUMENTAL",
                contentURI: "ipfs://QmRxKWkvfkxY215RX3k9CLtZJuPLyvZbomke7Jd69WKuaQ"
            },
            {
                name: "RIDE_OR_DIE",
                contentURI: "ipfs://QmQmb9hEBgZQSkLdYGpSdb79169VKnMjswdHFajNJA46XJ"
            }
        ];

        const PREMIUM_CONTENT = [
            {
                name: "PSILOCYBIN_ANIMATION_PART_1",
                contentURI: "ipfs://QmbJuivmDpfyPt3tqV33HP54KZ73MLFtmv3w95jkkeZ2pT"
            },
            {
                name: "PSILOCYBIN_ANIMATION_PART_2", 
                contentURI: "ipfs://QmRgEFHnQgFhJ7UdAccRzkBAX8FVK3Ld5vPp9NB3foLDqN"
            },
            {
                name: "PSILOCYBIN_ANIMATION_PART_3",
                contentURI: "ipfs://QmRNGhoDKWwKU78s5NRDmaMWnoMeds4KpUK5J6UMuYih3a"
            },
            {
                name: "MORE_ANIMATION_PART_1",
                contentURI: "ipfs://QmeyxCY8mauPzG2zcXjc3uVjewY5wLbg345AknAe6Gh434"
            },
            {
                name: "MORE_ANIMATION_PART_2",
                contentURI: "ipfs://QmaYmBcmCqLciMkvHARqjZZ6D6yoi37rM1PsstW9McRHj2"
            }
        ];

        const ELITE_CONTENT = [
            {
                name: "MORE_ANIMATION_FULL",
                contentURI: "ipfs://QmWjfHYUj8aQu3MuPcqwxJRfKwd7Be3rkkTpNUk1Tbt9Fk"
            },
            {
                name: "PSILOCYBIN_ANIMATION_BONUS",
                contentURI: "ipfs://QmSr1xSpQc7EwKWpFANoAVyGYzWnvr7BtJyTobRRUcrNyq"
            }
        ];

        // Update forgeCrystal function
        async function forgeCrystal() {
            const forgeCrystal = document.getElementById('forgeCrystal');
            const forgeStatus = document.getElementById('forgeStatus');
            
            try {
                forgeCrystal.disabled = true;
                if (forgeStatus) {
                    forgeStatus.style.display = 'block';
                    forgeStatus.textContent = 'CHECKING BALANCE...';
                }

                // Get selected crystal type
                const crystalType = document.getElementById('crystalType').value;
                
                // Get mint cost
                const mintCost = await memoryCrystal.getMintCost(crystalType);
                
                // Check if user can afford
                const userAddress = await walletService.getAddress();
                const balance = await signer.provider.getBalance(userAddress);
                
                if (balance < mintCost) {
                    throw new Error(`Insufficient funds. Required: ${ethers.formatEther(mintCost)} ETH, Available: ${ethers.formatEther(balance)} ETH`);
                }
                
                if (forgeStatus) forgeStatus.textContent = 'FORGING CRYSTAL...';
                
                // Forge crystal
                const tx = await memoryCrystal.forgeCrystal(crystalType, {
                    value: mintCost
                });
                
                if (forgeStatus) forgeStatus.textContent = 'CONFIRMING FORGE...';
                const receipt = await tx.wait();
                
                // Get the crystal ID from the event
                const forgeEvent = receipt.logs.find(log => {
                    try {
                        return log.topics[0] === ethers.id(
                            "CrystalForged(uint256,address,uint8)"
                        );
                    } catch (e) {
                        return false;
                    }
                });
                
                if (!forgeEvent) {
                    throw new Error('Failed to get crystal ID from event');
                }
                
                // Parse the tokenId directly from the event topic
                const crystalId = ethers.getBigInt(forgeEvent.topics[1]);
                
                if (!crystalId) {
                    throw new Error('Failed to get crystal ID from event');
                }
                
                console.log('Forged Crystal ID:', crystalId.toString());

                // Set content URI based on access level
                if (forgeStatus) forgeStatus.textContent = 'SETTING CONTENT...';
                
                let selectedContent;
                if (crystalType === '0') { // BASIC
                    selectedContent = BASIC_SONGS[Math.floor(Math.random() * BASIC_SONGS.length)];
                } else if (crystalType === '1') { // PREMIUM
                    selectedContent = PREMIUM_CONTENT[Math.floor(Math.random() * PREMIUM_CONTENT.length)];
                } else if (crystalType === '2') { // ELITE
                    selectedContent = ELITE_CONTENT[Math.floor(Math.random() * ELITE_CONTENT.length)];
                }

                if (selectedContent) {
                    await memoryCrystal.setContentURI(crystalId, selectedContent.contentURI);
                }
                
                // Bind the crystal to holder
                if (forgeStatus) forgeStatus.textContent = 'BINDING CRYSTAL...';
                try {
                    // Ask user to confirm binding and warn about popup
                    if (!confirm('Crystal forged successfully! Click OK to bind it to your holder. Please ensure popups are allowed for this site.')) {
                        throw new Error('Crystal binding cancelled by user');
                    }
                    
                    // Add a longer delay before binding to ensure wallet UI is ready
                    await new Promise(resolve => setTimeout(resolve, 3000));
                    
                    // Use fixed gas limit for binding
                    const bindTx = await crystalHolder.bindCrystal(crystalId, {
                        gasLimit: 100000 // Fixed gas limit that should be sufficient for binding
                    }).catch(async (error) => {
                        if (error.message.includes('Pop up window failed to open')) {
                            // If popup fails, ask user to enable popups and try again
                            if (confirm('Popup was blocked. Please enable popups for this site and click OK to try again.')) {
                                await new Promise(resolve => setTimeout(resolve, 2000));
                                return crystalHolder.bindCrystal(crystalId, {
                                    gasLimit: 100000
                                });
                            }
                        }
                        throw error;
                    });
                    
                    if (forgeStatus) forgeStatus.textContent = 'CONFIRMING BIND...';
                    const bindReceipt = await bindTx.wait();
                    
                    if (!bindReceipt.status) {
                        throw new Error('Crystal binding failed');
                    }
                    
                    // Update crystal vault display
                    if (forgeStatus) forgeStatus.textContent = 'UPDATING VAULT...';
                    await updateCrystalVault();
                    
                    alert(`Successfully forged and bound Crystal #${crystalId}!`);
                } catch (bindError) {
                    console.error('Error binding crystal:', bindError);
                    throw new Error(`Failed to bind crystal: ${bindError.message}`);
                }
                
                alert(`Successfully forged and bound Crystal #${crystalId}!`);
                
            } catch (error) {
                console.error('Error forging crystal:', error);
                alert('Failed to forge crystal: ' + error.message);
            } finally {
                if (forgeStatus) {
                    forgeStatus.style.display = 'none';
                }
                forgeCrystal.disabled = false;
            }
        }
    </script>
</body>
</html> 